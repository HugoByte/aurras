// Copyright 2023  HugoByte AI Labs Pvt Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

mod common;
mod traits;
mod types;
extern crate alloc;

/
* USER IMPORTS

*/



/* 
MAIN ENTRY POINT OF WASM BINARY WHERE ITS EXECUTED

*/
#[no_mangle]
pub fn _start(ptr: *mut u8, length: i32) {
    let result: Value;
    unsafe {
        let mut vect = Vec::new();
        for i in 1..=length {
            if let Some(val_back) = ptr.as_ref() {
                vect.push(val_back.clone());
            }
            *ptr = *ptr.add(i as usize);
        }
        result = serde_json::from_slice(&vect).unwrap();
    }

    let res = main(result);
    let output = Output {
        result: serde_json::to_value(res).unwrap(),
    };
    let serialized = serde_json::to_vec(&output).unwrap();
    let size = serialized.len() as i32;
    let ptr = serialized.as_ptr();
    std::mem::forget(ptr);
    unsafe {
        set_output(ptr as i32, size);
    }
}

/*
Memory allocation and Free functions for Wasm Binary
*/
#[no_mangle]
pub unsafe extern "C" fn memory_alloc(size: u32, alignment: u32) -> *mut u8 {
    let layout = Layout::from_size_align_unchecked(size as usize, alignment as usize);
    alloc::alloc::alloc(layout)
}

#[no_mangle]
pub unsafe extern "C" fn free_memory(ptr: *mut u8, size: u32, alignment: u32) {
    let layout = Layout::from_size_align_unchecked(size as usize, alignment as usize);
    alloc::alloc::dealloc(ptr, layout);
}


/* 
MAIN FUNCTION WHICH IS GENERATED BY PROVIDER USING YAML
*/

#[allow(dead_code, unused)]
pub fn main(args: Value) -> Result<Value, String> {

    const LIMIT: usize = {{NUMBER_OF_TASK}}; // Added via providers 
    let mut workflow = WorkflowGraph::new(LIMIT); // Initialisation of Workflow Dag

    let input: Input = serde_json::from_value(args).map_err(|e| e.to_string())?; // Deserialisation of values to Input Struct

    /*
    INITIALISATION OF TASK 

    example :
    */


    let task1 = Task1::new(input.task1field,String::from("task1"));
    let task2 = Task2::new(input.task2field,String::from("task2"));

    /*
    Adding tasks as a node of workflow Dag

    example

    */
    let task1_index = workflow.add_node(Box::new(task1));
    let task2_index = workflow.add_node(Box::new(task2));
    /*
    Mapping edges in workflow graph

    example

    */
    workflow.add_edges[&(task1_index,task2_index)]
    /*
    
    Order Of Execution based on the flow defined in the Yaml

    example   
    */

    let result = workflow.init()?.pipe(task2_index).term(None)

    /*
    Returning result as the value 
    */
    let result = serde_json::to_value(result).unwrap();
    Ok(result)
}